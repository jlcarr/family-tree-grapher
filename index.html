<!DOCTYPE html>
<html>
<body>

<h1>Family Tree Grapher</h1>

<h2>Description</h2>
<p>
This tool will render a GEDCOM file to SVG format.
</p>

<h2>Inputs</h2>
<input type="file" id="file-input"/>

<h2>Result</h2>
<div style="border:1px solid black;width: 100%;height:100%; overflow:scroll;" id="file-image">
	<embed src="https://upload.wikimedia.org/wikipedia/commons/e/e9/SVG-Grundelemente.svg" type="image/svg+xml">
</div>

</body>


<script>
function render_family_tree(GEDCOM_string){
	var SVG_string = GEDCOM2SVG(GEDCOM_string);
	console.log(SVG_string);
	var element = document.getElementById('file-image');
	element.textContent = SVG_string;
}

function GEDCOM2SVG(GEDCOM_string){
	// Initial JSON parse of the file
	var GEDCOM_json = GEDCOM2JSON(GEDCOM_string);
	
	// Clean into family structure
	var clean_GEDCOM_json = clean_GEDCOM_JSON(GEDCOM_json);
	
	// Generate descendents tree
	var descendents_tree = generate_descendents_tree(clean_GEDCOM_json);
	
	return JSON.stringify(descendents_tree);
}

function GEDCOM2JSON(GEDCOM_string){
	var return_value = {'children':[]};
	var obj_stack = [return_value];
	var lines = GEDCOM_string.split(/\r\n|\r|\n/);
	for (line of lines){
		// Parse the line
		var tokens = line.split(' ');
		var depth = parseInt(tokens[0]);
		var tag = tokens[1];
		
		// Get the current object (should always pop at least once)
		while (depth < obj_stack.length) var current_obj = obj_stack.pop();
		
		// Check the current object status
		var new_obj = {'tag': tag, 'children': []};
		if (tokens.length > 2) new_obj['value'] = tokens.slice(2).join(' ');
		current_obj['children'].push(new_obj)
		
		// Replace the current object on the stack, with new on top
		obj_stack.push(current_obj);
		obj_stack.push(new_obj);
	}
	return return_value;
}

function clean_GEDCOM_JSON(GEDCOM_json){
	// Clean into family structure
	var INDI_dict = {};
	var FAM_dict = {};
	for (entity of GEDCOM_json['children']){
		// Individual
		if ('value' in entity && entity['value'] == 'INDI'){
			var new_INDI = {'spouse_fam':[]};
			for (attribute of entity['children']){
				if (attribute['tag'] == 'NAME' && 'value' in attribute) new_INDI['name'] = attribute['value'];
				if (attribute['tag'] == 'SEX' && 'value' in attribute) new_INDI['sex'] = attribute['value'];
				if (attribute['tag'] == 'FAMS' && 'value' in attribute) new_INDI['spouse_fam'].push(attribute['value']);
				if (attribute['tag'] == 'FAMC' && 'value' in attribute) new_INDI['child_fam'] = attribute['value'];
				if (attribute['tag'] == 'BIRT'){
					for (attribute_sub of attribute['children']){
						if (attribute_sub['tag'] == 'DATE' && 'value' in attribute_sub) new_INDI['birthdate'] = attribute_sub['value'];
					}
				}
			}
			INDI_dict[entity['tag']] = new_INDI;
		}
		// Family
		if ('value' in entity && entity['value'] == 'FAM'){
			var new_FAM = {'children':[]};
			for (attribute of entity['children']){
				if (attribute['tag'] == 'HUSB' && 'value' in attribute) new_FAM['father'] = attribute['value'];
				if (attribute['tag'] == 'WIFE' && 'value' in attribute) new_FAM['mother'] = attribute['value'];
				if (attribute['tag'] == 'CHIL' && 'value' in attribute) new_FAM['children'].push(attribute['value']);
				if (attribute['tag'] == 'MARR'){
					for (attribute_sub of attribute['children']){
						if (attribute_sub['tag'] == 'DATE' && 'value' in attribute_sub) new_FAM['marriage date'] = attribute_sub['value'];
					}
				}
			}
			FAM_dict[entity['tag']] = new_FAM;
		}
	}
	clean_GEDCOM_json = {'INDI_dict': INDI_dict, 'FAM_dict':FAM_dict};
	return clean_GEDCOM_json;
}

function generate_descendents_tree(clean_GEDCOM_json){
	var INDI_dict = clean_GEDCOM_json.INDI_dict;
	var FAM_dict = clean_GEDCOM_json.FAM_dict;
	
	// Generate descendents tree
	var descendents_tree = {'key':'@I2@', 'generation': 1}
	var search_stack = [descendents_tree]; //INDI_dict.keys().filter(indi => !('child_fam' in INDI_dict[indi]));
	while (search_stack.length){
		var curr = search_stack.pop();
		var curr_JSON = INDI_dict[curr['key']]
		curr['name'] = curr_JSON['name'];
		curr['birthdate'] = curr_JSON['birthdate'];
		if (curr_JSON['spouse_fam'].length){
			var curr_fam = FAM_dict[curr_JSON['spouse_fam'][0]];
			curr['spouse_key'] = curr_fam['mother'] != curr['key'] ? curr_fam['mother'] : curr_fam['father'];
			var spouse_JSON = INDI_dict[curr['spouse_key']];
			curr['spouse'] = spouse_JSON['name']
			curr['spouse_birthdate'] = spouse_JSON['birthdate']
			curr['children'] = [];
			for (child of curr_fam['children']){
				var new_child = {'key': child, 'generation': curr['generation']+1};
				curr['children'].push(new_child);
				search_stack.push(new_child);
			}
		}
	}
	return descendents_tree;
}

function readSingleFile(e) {
	var file = e.target.files[0];
	if (!file) return;
	
	var reader = new FileReader();
	reader.onload = (e) => render_family_tree(e.target.result);
	reader.readAsText(file);
}

document.getElementById('file-input')
	.addEventListener('change', readSingleFile, false);
</script>
</html>

